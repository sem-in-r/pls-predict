#' PIntervals generates Prediction Intervals for SEMinR PLS models
#'
#' \code{validatePredict} generates average-case and case-wise prediction intervals for PLS models generated by SEMinR.
#'
#' This function generates average-case and case-wise prediction intervals for PLS models generated by SEMinR.
#'
#' @param model A SEMinR model that has been trained on the training data
#'
#' @param testData The testdata for which prediction intervals will be generated.
#'
#' @param technique The predictive technique to be employed, Earliest Antecedents (EA) \code{predict_EA} or
#' Direct Antecedents (DA) \code{predict_DA}
#'
#' @param PIprobs The required confidence level for prediction intervals. Default is 0.9 (10 percent)
#'
#' @param noBoots The number of bootstraps to perform. Default is 200.
#'
#' @usage
#'
#' predictionInterval(model, testData, technique, PIprobs, noBoots)
#'
#' @examples
#' library(seminr)
#' data(mobi)
#' trainData <- mobi[1:200,]
#' testData <- mobi[201:250,]
#'
#' # seminr syntax for creating measurement model
#' mobi_mm <- constructs(
#'   composite("Image",        multi_items("IMAG", 1:5)),
#'   composite("Expectation",  multi_items("CUEX", 1:3)),
#'   composite("Value",        multi_items("PERV", 1:2)),
#'   composite("Satisfaction", multi_items("CUSA", 1:3))
#' )
#'
#' mobi_sm <- relationships(
#'   paths(to = "Satisfaction",
#'         from = c("Image", "Expectation", "Value"))
#' )
#'
#' mobi_train <- estimate_pls(trainData, mobi_mm, interactions = NULL, mobi_sm)
#' prediction_intervals <- predictionInterval(mobi_train, testData)
#'
#' @export
predictionInterval <- function(model, testData, technique = predict_DA, PIprobs = 0.9,noBoots=200){

  # AVERAGE CASE PREDICTION INTERVAL
  # initialize output prediction dataframe
  # initialize output residual dataframe
  # TODO: get output factors (don't assume they are reflective)
  tempPredict <- as.data.frame(matrix(ncol=0, nrow=nrow(testData)))
  tempResidual <- as.data.frame(matrix(ncol=0, nrow=nrow(testData)))
  tempHolder <- as.data.frame(matrix(ncol=0, nrow=nrow(testData)))
  tempTotal <- as.data.frame(matrix(ncol=0, nrow=nrow(testData)))

  #Bootstrap
  #TODO: parallelize bootstrap
  for (i in 1:noBoots) {
    boot.index <- sort(sample(1:nrow(model$data), replace=TRUE))
    trainData.boot <- model$data[boot.index,]

    #Call PLSpredict
    utils::capture.output(trainModel <- seminr::estimate_pls(trainData.boot,
                               measurement_model = model$mmMatrix,
                               structural_model = model$smMatrix))
    tempModel <- PLSpredict(model = trainModel,
                            testData = testData,
                            technique = technique)
    tempPredict <- cbind(tempPredict,data.frame(tempModel$predicted_Measurements))
    tempResidual <- cbind(tempResidual,data.frame(tempModel$residuals))
  }

  # Initialize Average Case PI holder
  quantHolder <- list(NULL)

  func <- TeachingDemos::emp.hpd
  # Calculate Quantiles HPD
  for (n in 1:length(model$mmVariables)) {
    quantHolder[[n]] <- data.frame(apply(tempPredict[,colnames(tempPredict)==model$mmVariables[n]] , 1, func, conf = PIprobs))
  }

  # Initialize Casewise PI holder
  casewiseHolder <- list(NULL)

  # Randomly shuffle indexes for random error retrieval
  # Columnwise, shuffle the tempResiduals rows
  for (q in 1:ncol(tempResidual)) {
    index <- sample.int(dim(testData),replace=F)
    tempHolder[,q] <- tempResidual[index,q]
  }

  # Add the predicted values and random error (residuals)
  tempTotal <- tempHolder + tempPredict
  names(tempTotal) <- names(tempResidual)

  # and calculate quantiles HPD on
  for (n in 1:length(model$mmVariables)) {
    casewiseHolder[[n]] <- data.frame(apply(tempTotal[,colnames(tempTotal)==model$mmVariables[n]] , 1, func, conf = PIprobs))
  }

  names(casewiseHolder) <- names(quantHolder) <- model$mmVariables

  PIresults <- list(averageCasePI = quantHolder,
                    caseWisePI = casewiseHolder)
  return(PIresults)
}
