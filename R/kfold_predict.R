#' Predict_pls performs either k-fold or LOOCV on a SEMinR PLS model and generates predictions
#'
#' \code{predict_pls} uses cross-validation to generate in-sample and out-sample predictions for PLS models generated by SEMinR.
#'
#' This function generates cross-validated in-sample and out-sample predictions for PLS models generated by SEMinR. The
#' cross validation technique can be k-fold if a number of folds are specified, or leave-one-out-cross-validation (LOOCV) if no folds
#' arew specified. LOOCV is recommended for small datasets.
#'
#' @param model A SEMinR model that has been estimated on the FULL dataset.
#'
#' @param technique The predictive technique to be employed, Earliest Antecedents (EA) \code{predict_EA} or
#' Direct Antecedents (DA) \code{predict_DA}
#'
#' @param noFolds The required number of folds to use in k-fold cross validation. If NULL, then parallel LOOCV will be executed.
#' Default is NULL.
#'
#' @param cores The number of cores to use for parallel LOOCV processing. If k-fold is used, the process will not be parallelized.
#'
#' @usage
#'
#' predict_pls(model, technique, noFolds, cores)
#'
#' @examples
#' library(seminr)
#' data(mobi)
#'
#' # seminr syntax for creating measurement model
#' mobi_mm <- constructs(
#'   composite("Image",        multi_items("IMAG", 1:5)),
#'   composite("Expectation",  multi_items("CUEX", 1:3)),
#'   composite("Value",        multi_items("PERV", 1:2)),
#'   composite("Satisfaction", multi_items("CUSA", 1:3))
#' )
#'
#' mobi_sm <- relationships(
#'   paths(to = "Satisfaction",
#'         from = c("Image", "Expectation", "Value"))
#' )
#'
#' mobi_pls <- estimate_pls(mobi, mobi_mm, interactions = NULL, mobi_sm)
#' cross_validated_predictions <- predict_pls(model = mobi_pls,
#'                                            technique = predict_DA,
#'                                            noFolds = 10,
#'                                            cores = NULL)
#'
#' @export
predict_pls <- function(model, technique = predict_DA, noFolds = NULL, cores = NULL) {

  stopifnot(inherits(model, "seminr_model"))

  # shuffle data
  order <- sample(nrow(model$data),nrow(model$data), replace = FALSE)
  ordered_data <- model$data[order,]

  # collect in-sample and out-sample prediction matrices and sort everything to original row indexes
  pred_matrices <- prediction_matrices( noFolds, ordered_data, model,technique, cores)
  PLS_predicted_outsample_construct <- pred_matrices$out_of_sample_construct[as.character(c(1:nrow(model$data))),]
  PLS_predicted_insample_construct <- pred_matrices$in_sample_construct[as.character(c(1:nrow(model$data))),]
  PLS_predicted_outsample_item <- pred_matrices$out_of_sample_item[as.character(c(1:nrow(model$data))),]
  PLS_predicted_insample_item <- pred_matrices$in_sample_item[as.character(c(1:nrow(model$data))),]
  LM_predicted_outsample_item <- pred_matrices$out_of_sample_lm_item[as.character(c(1:nrow(model$data))),]
  LM_predicted_insample_item <- pred_matrices$in_sample_lm_item[as.character(c(1:nrow(model$data))),]

  # Allocate results
  results <- list(composites = list(composite_out_of_sample = PLS_predicted_outsample_construct,
                                    composite_in_sample = PLS_predicted_insample_construct,
                                    actuals_star = model$construct_scores[as.character(c(1:nrow(model$data))),]),
                  items = list(item_out_of_sample = PLS_predicted_outsample_item,
                               item_in_sample = PLS_predicted_insample_item,
                               lm_out_of_sample = LM_predicted_outsample_item,
                               lm_in_sample = LM_predicted_insample_item,
                               item_actuals = ordered_data[as.character(c(1:nrow(model$data))),],
                               lm_in_sample_residuals = pred_matrices$lm_in_sample_item_residuals[as.character(c(1:nrow(model$data))),],
                               pls_in_sample_residuals = pred_matrices$pls_in_sample_item_residuals[as.character(c(1:nrow(model$data))),]))
  class(results) <- "pls_prediction_kfold"
  return(results)
}
