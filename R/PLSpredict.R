#' PLSpredict performs predictions on SEMinR PLS models
#'
#' \code{PLSpredict} performs predictions on PLS models generated by SEMinR.
#'
#' This function performs construct and item level predictions
#'
#' @param model A SEMinR model that has been trained on the training data
#'
#' @param testData The testing data for which predictions will be generated
#'
#' @param technique The predictive technique to be employed, Earliest Antecedents (EA) \code{predict_EA} or
#' Direct Antecedents (DA) \code{predict_DA}
#'
#' @usage
#'
#' PLSpredict(model, testData, technique)
#'
#' @examples
#' library(seminr)
#' data(mobi)
#' trainData <- mobi[1:200,]
#' testData <- mobi[201:250,]
#'
#' # seminr syntax for creating measurement model
#' mobi_mm <- constructs(
#'   composite("Image",        multi_items("IMAG", 1:5)),
#'   composite("Expectation",  multi_items("CUEX", 1:3)),
#'   composite("Value",        multi_items("PERV", 1:2)),
#'   composite("Satisfaction", multi_items("CUSA", 1:3))
#' )
#'
#' mobi_sm <- relationships(
#'   paths(to = "Satisfaction",
#'         from = c("Image", "Expectation", "Value"))
#' )
#'
#' mobi_train <- estimate_pls(trainData, mobi_mm, interactions = NULL, mobi_sm)
#' predictions <- PLSpredict(mobi_train, testData)
#'
#' @export
PLSpredict <- function(model, testData, technique = predict_DA){
  #Get results from training model
  smMatrix <- model$smMatrix
  mmMatrix <- model$mmMatrix
  ltVariables <- model$ltVariables
  mmVariables <- model$mmVariables
  outer_weights <- model$outer_weights
  outer_loadings <- model$outer_loadings
  meanData <- model$meanData
  sdData <- model$sdData
  path_coef<- model$path_coef

  #Create container for Exogenous Variables
  exVariables = NULL

  #Create container for Endogenous Variables
  enVariables = NULL

  #Identify Exogenous and Endogenous Variables
  exVariables <- unique(smMatrix[,1])
  pMeasurements <- NULL
  for (i in 1:length(exVariables)){
    pMeasurements <- c(pMeasurements,mmMatrix[mmMatrix[,"construct"]==exVariables[i],"measurement"])
  }
  enVariables <- unique(smMatrix[,2])
  resMeasurements <- NULL
  for (i in 1:length(enVariables)){
    resMeasurements <- c(resMeasurements, mmMatrix[mmMatrix[, "construct"] == enVariables[i],"measurement"])
  }
  enVariables <- setdiff(enVariables,exVariables)
  eMeasurements <- NULL
  for (i in 1:length(enVariables)){
    eMeasurements <- c(eMeasurements, mmMatrix[mmMatrix[, "construct"] == enVariables[i],"measurement"])
  }

  #Extract Measurements needed for Predictions
  normData <- testData[,pMeasurements]

  #Normalize data
  for (i in pMeasurements)
  {
    normData[,i] <-(normData[,i] - meanData[i])/sdData[i]
  }

  #Convert dataset to matrix
  normData<-data.matrix(normData)

   #Add empty columns to normData for the estimated measurements
  for (i in 1:length(eMeasurements))
  {
    normData = cbind(normData, seq(0,0,length.out =nrow(normData)))
    colnames(normData)[length(colnames(normData))]=eMeasurements[i]
  }

  #Estimate Factor Scores from Outter Path
  fscores <- normData%*%outer_weights

  #Estimate Factor Scores from Inner Path and complete Matrix
  fscores <- technique(smMatrix, path_coef, fscores)

  #Predict Measurements with loadings
  predictedMeasurements<-fscores%*% t(outer_loadings)

  #Denormalize data
  for (i in mmVariables)
  {
    predictedMeasurements[,i]<-(predictedMeasurements[,i] * sdData[i])+meanData[i]
  }

  #Calculating the residuals
  residuals <- testData[,resMeasurements] - predictedMeasurements[,resMeasurements]

  #Prepare return Object
  predictResults <- list(testData = testData[,resMeasurements],
                         predicted_Measurements = predictedMeasurements[,resMeasurements],
                         residuals = residuals,
                         predicted_CompositeScores = fscores)

  class(predictResults) <- "predictResults"
  return(predictResults)
}
